# 单调队列----dp优化

## 定义：

什么是「单调队列」？顾名思义，「单调队列」就是队列内元素满足单调性的队列结构。

## 操作维护：（递增）

「单调队列」中「队尾」的操作与「单调栈」中「栈顶」的操作一致，即假设当前元素为 x，若队尾元素 <= x，则将 x 入队，否则不断弹出队首元素（单调栈是栈顶），直至队尾元素 <= x。

## 性质：求定长区间最值：队首/尾

有一个长为 n的序列 a *，以及一个大小为 k* 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

### 单调性：定长区间最值

#### 维护长度为<=k的单调队列  数组模拟   stl不易实现 队尾删

最大值：单调递减队列，队首为max，每次队尾pop比a[i]小的

### 一些细节：

一般head  tail可初始化为  0，0  ; -1，0  ；1,0;但当涉及某些前缀问题，(开始会调用q[head] q[0]的值，例2，4)只能0，0  //第一个元素初始化q[0]=0;     i-1  下标从0开始 

(无脑0，0)

### 例题：

#### 例1：模板题：

[滑动窗口]:https://www.luogu.com.cn/problem/P1886

```C++
#include <bits/stdc++.h>
//# pragma GCC optimize(3)
#define int long long
#define endl "\n"
using namespace std;

const int N = 2e6+ 5;
int T, n, k,a[N];
int q[N]; //单调队列  存的是下标  也可以多开一个数组存下标
void solve(){
    cin>>n>>k;
    //最小值;单调递增
    for(int i=1;i<=n;i++)cin>>a[i];
    int head=1,tail=0;  //   -1和0; 0,0也可
    for(int i=1;i<=n;i++){// 每次移动一个元素入队
		if(head<=tail&&i-k+1>q[head])head++; //队首已不在窗口内  
        while(head<=tail&&a[q[tail]]>=a[i])tail--; //pop 掉队尾大于a[i]的 (在前面且小于)
    	q[++tail]=i ; //新元素入队
    	if(i>=k)cout<<a[q[head]]<<" "; //输出队首元素max
    }
    cout<<endl;
    //最大值同理
    head=1,tail=0;  
    for(int i=1;i<=n;i++){// 每次一个元素入队
		if(head<=tail&&i-k+1>q[head])head++; //队首已不在窗口内  
        while(head<=tail&&a[q[tail]]<=a[i])tail--; //pop 掉队尾小于a[i]的 (在前面且小于)
    	q[++tail]=i ; //新元素入队
    	if(i>=k) //窗口已进入
            cout<<a[q[head]]<<" "; // 输出队首元素max
    }


}
signed main() {
  std::ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);

      solve();
  
  return 0;
}

```

#### 例2：acw135. 最大子序和

[最大子序和]:https://www.acwing.com/problem/content/137/

输入一个长度为 n 的整数序列，从中找出一段长度不超过 m 的连续子序列，使得子序列中所有数的和最大。

##### 思路：

滑动窗口变形：定长区间（<=len）最值问题

分析： 和最大  设a[i] 为 以i结尾的和最大的序列  则a[i ] =sum[i]  - sum[j]  (i-k+1<j<i)  问题转化为 定长区间内sum[j] 的最小值minn  ans=max(ans,sum[i]-minn)

做前缀和     用滑动窗口做法即可

```C++
#include <bits/stdc++.h>
//# pragma GCC optimize(3)
#define int long long
#define endl "\n"
using namespace std;

const int N = 2e6+ 5;
int T, n, k,a[N],sum[N];
int q[N]; //单调队列  存的是下标  也可以多开一个数组存下标
void solve(){
    cin>>n>>k;
    //最小值;单调递增
    memset(sum,0,sizeof sum);
    for(int i=1;i<=n;i++)cin>>a[i],sum[i]=sum[i-1]+a[i];
    int head=1,tail=0;   // head初始为0*因为这里是0~i-1的最小值,相当于sum下标从0开始
    // q[0]=0;
 	int ans=-0x3f3f3f3f;
    for(int i=1;i<=n;i++){
                //长度限制
       if(head<=tail&&(i)-k+1>q[head])head++;  //前i-1个中最小值 
       ans=max(ans,sum[i]-sum[q[head]]); //找i之前的最小值
       while(head<=tail&&sum[q[tail]]>=sum[i])tail--;   //加入i
       q[++tail]=i ; 
    }
cout<<ans<<endl;
}
signed main() {
  std::ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);
      solve();
  return 0;
}

```

#### 例3.acw1088. 旅行问题

与例2类似，环形 ，破换成链 2倍（2*n）   判断前缀和所有长度为n的区间最小值是否小于0

做法同例2

```C++
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;

const int N=2e6+10;

long long s[N*2];//前缀和
int q[N*2],o[N],d[N],mark[N];
//o[i]表示到i地点所需要的油,d[i]表示i到i+1消耗的油,mark[i]等于1时表示能环球旅行,0时不能

int main()
{
    int n;
    scanf("%d",&n);

    for(int i=1;i<=n;i++) scanf("%d%d",&o[i],&d[i]);

    //计算前缀和
    for(int i=1;i<=n;i++) s[i]=s[i+n]=o[i]-d[i];//表示i地点加的油和到下一地点消耗的油的差
    for(int i=1;i<=2*n;i++) s[i]+=s[i-1];

    int hh=1,tt=0;
    for(int i=2*n;i>=1;i--)
    {
        //长度限制
        if(hh<=tt&&q[hh]>i+n-1) hh++;//窗口范围为n
			
        while(hh<=tt&&s[q[tt]]>=s[i]) tt--;//保持单调递增,q中大于s[i]的都出队
        q[++tt]=i;//s[i]入队

        if(i<=n&&s[q[hh]]>=s[i-1]) mark[i]=1;//最小值大于,那么可以环球旅行
    }

    //逆时针顺序
    hh=0,tt=-1;
    d[0]=d[n];//s[1]计算的时候需要
    for(int i=1;i<=n;i++) s[i]=s[i+n]=o[i]-d[i-1];
    for(int i=2*n;i>=0;i--) s[i]+=s[i+1];//因为为逆时针,所以s数组从后往前看

    for(int i=1;i<=2*n;i++)
    {
        if(hh<=tt&&q[hh]<i-n+1) hh++;//范围在n之内

        while(hh<=tt&&s[q[tt]]>=s[i]) tt--;//保持单调递增,q中大于s[i]的都出队
        q[++tt]=i;//s[i]进队
        if(i>n&&s[q[hh]]>=s[i+1]) mark[i-n]=1;//因为单调递减性,n范围内s[q[hh]]为最小值.
    }

    for(int i=1;i<=n;i++)
    if(mark[i]) printf("TAK\n");
    else printf("NIE\n");

    return 0;
}


```



####例4. hdu3530:Subsequence

##### 题意：

  题意： 给n个数，求一个最长连续子序列，在这个子序列中，最大值与最小值之差要在区间[m,k]内，输出这个子序列的长度。

##### 思路：

用两个单调队列，一个递增，一个递减，然后枚举区间尾，不断维护两个队列，那么队首就是最大/小值，需要注意的是，当队首元素之差小于m时，不需要更新队列（因为如果后面有更大的元素进来，差可能就会大于等于m），而当队首元素之差大于k时，将两个队列中较小的队首出队，并用last标记，表示这是最新的被淘汰的下标，即所求区间的 前一个元素下标，于是答案ans=max（ans,i-last），所求区间为[last+1,i]。

```C++
#include <bits/stdc++.h>
//# pragma GCC optimize(3)
#define int long long
#define endl "\n"
using namespace std;

const int N = 2e5 + 5;
int T, n,m,k, a[N];
int q1[N],q2[N];
void solve(){
    for(int i=1;i<=n;i++)cin>>a[i];
    int head1=1,tail1=0,head2=1,tail2=0;
    memset(q1,0,sizeof q1);
    memset(q2,0,sizeof q2);
    int ans=0;
    int pos=1; //每次加入后满足的首元素
    for(int i=1;i<=n;i++){
		//无长度限制
        while(head1<=tail1&&a[q1[tail1]]>=a[i])tail1--;//递增  min
        q1[++tail1]=i;//入队
        while(head2<=tail2&&a[q2[tail2]]<=a[i])tail2--;//递减 max
        q2[++tail2]=i;
        while(a[q2[head2]]-a[q1[head1]]>k){ //本题关键操作 差值需要小于k  大于则后移head			
			pos=q1[head1]<q2[head2]?q1[head1++]+1:q2[head2++]+1;//找更大的 后移
        }//满足的是跳出前后一位
        if(a[q2[head2]]-a[q1[head1]]>=m) //
        	ans=max(ans,i-pos+1);   // 
    }
cout<<ans<<endl;



}
signed main() {
  std::ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);

  while(cin>>n>>m>>k)
      solve();
  return 0;
}

```

#### 例5.1089. 烽火传递   (优化dp入门)

##### 题目描述

给定一个长度为 n 的数组 w，以及一个正整数 m
其中 wi 表示第 i 个 元素 的 价值

求一种选择元素的 方案：

使得选择的 相邻元素 之间相差 不超过 m−1 个 不选 的元素
选择的元素总贡献 最小

##### 状态表示：***

dp[i] 表示已 i 为右端点且选择i的合法方案代价最小值

##### 状态计算 

dp[i] =w[i] +min{dp[j] }    (i-m<=j<i-1)

定长区间最小值问题 维护单调同时进行状态转移即可

##### 优化：

O(n^2)->O(n)

```C++
#include <bits/stdc++.h>
//# pragma GCC optimize(3)
#define int long long
#define endl "\n"
using namespace std;

const int N = 2e5 + 5;
int T, n,m, w[N];
int dp[N];
int q[N];
void solve(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)  cin>>w[i];
    int head=0,tail=0; //这里只能0，0  i-1  下标从0开始 q[0]=0;
    for(int i=1;i<=n;i++){
        if(head<=tail&&(i-1)-q[head]+1>m)head++;  // i-1到q[head] 前m个
        dp[i]=dp[q[head]]+w[i]; //前面的最小值 转移
    	while(head<=tail&&dp[q[tail]]>=dp[i])tail--;//维护单增
        q[++tail]=i;
    }
    //接下来找dp[i] 的最小值 可以枚举  但由于队首就是最小值 i=n时对应i-1及前m个
    //所以再滑动一位输出队首即可(i==n+1)
    if(n+1-q[head]>m)head++;
	cout<<dp[q[head]]<<endl;
}
signed main() {
  std::ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);


      solve();
  
  return 0;
}

```

#### 例6.acw1090绿色通道（二分+单调队列优化）

就是加二分的上一题

##### 题目描述

给定一个 正整数 m，以及一个长度为 n 的正整数 数组 w，其中 wi 为第 i 个元素的 价值

求一个选择元素的 方案，使得元素的 价值总和 不超过 m 且 相邻元素 的 间距最小

输出该 最小间距

##### 分析

直接做不是很好做，不妨把问题转化为我们熟悉的模型来求解

显然，答案是存在 单调性 的：

任意比 答案 小的 间距 的选择方案，其 元素总和 必然超过 m
任意比 答案 大或相等的 间距，必然存在一个方案，使得 元素总和 小于等于 m
对于 22是显然的，我们可以在原合法方案上，删去一些数，从而实现 间距 变大的操作

对于 1，我们可以用 反证法：若小于 答案 的 间距 存在符合条件的选元素方案

则我们的 答案 应该是该 间距，这与原答案 矛盾

找出该 单调性，我们就可以上 二分 了

现问题就转化成了：在确定 最小间距 情况下，能否找出选择 元素总和 小于等于 mm 的方案

该问题 等价于： 在确定 最小间距 情况下，选择 元素总和 最小的方案 价值 是否 小于等于 m



##### 状态表示：

dp[i] 表示已i为右端点且选i的方案 的最小代价

##### 状态转移：

dp[i] =min{dp[j]} +w[i];    (  i-mid<j<i-1  )

```C++
#include <bits/stdc++.h>
//# pragma GCC optimize(3)
#define int long long
#define endl "\n"
using namespace std;

const int N = 2e5 + 5;
int T, n,m, w[N];
int dp[N];
int q[N];
bool check(int mid){ //上一题的dp  check间距  
	 int head=0,tail=0; //这里只能0，0  i-1  下标从0开始 q[0]=0;
    for(int i=1;i<=n;i++){
        if(head<=tail&&(i-1)-q[head]+1>mid+1)head++;  //多加1  不超过
        dp[i]=dp[q[head]]+w[i]; //前面的最小值 转移
    	while(head<=tail&&dp[q[tail]]>=dp[i])tail--;//维护单增
        q[++tail]=i;
    }
    //接下来找dp[i] 的最小值 可以枚举  但由于队首就是最小值 i=n时对应i-1及前m个
    //所以再滑动一位输出队首即可(i==n+1)
    if(n+1-q[head]>mid+1)head++;
	return dp[q[head]]<=m; //
}

void solve(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)  cin>>w[i];
   int l=0,r=n+1;
    while(l<r){//二分答案
		int mid=(l+r)>>1;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    cout<<l<<endl;
}
signed main() {
  std::ios::sync_with_stdio(false);
  cin.tie(0);
  cout.tie(0);


      solve();
  
  return 0;
}

```

#### 例7.修剪草坪

##### 题目描述

给定一个长度为 n 的数组 w，其中 wi是第 i个元素的 贡献

我们可以选择的 数组 中的一些 元素，这些元素的 贡献总和 表示我们该种 方案 的 价值

但是，如果方案中出现选择了 连续相邻 且超过 m 个元素，则这些 连续相邻 的元素 贡献 归零

求解一种 方案，使得选择的 元素贡献总和 最大

##### 分析

考虑用 动态规划 来求解本问题

由于 连续选择 超过 m 个元素时，这些元素的 贡献 为 0 （相当于没选）

**而本题，所有的元素值都是 正整数，故我们的方案中，连续选择的元素数量 一定是 不超过 m 的**

可以用 反证法 证明，如果方案中有超过 m 个连续元素，则我们不选中间的一个，使他断开，必然不会使方案变差
	于是，我们就可以通过 ***最后一次没有选择的元素***，对 集合进行划分

闫氏DP分析法

##### 状态表示

 dp[i]：以 i为右端点的 前缀数组 的选择方案

##### 状态计算：

fi=max{f[j-1]+si−sj}0≤i−j≤m    (不选j) ------>         fi=si+max{f[j-1]−s[j]}    0≤i−j≤m
由于 j是有范围的：，于是问题就转化为 滑动窗口求极值 的问题了;我们用一个记录的 单调递减 的 f[j-1]−s[j]队列 在 队头 维护一个 最大值 即可

##### 边界：

dp[-1]=0

```C++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, m;
LL s[N], f[N];
int que[N];

LL g(int i)//即维护的  f[j-1]−s[j]
{
    return f[max(0, i - 1)] - s[i];  //f[-1]=f[0]
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%lld", &s[i]), s[i] += s[i - 1]; //前缀和

    int hh = 0, tt = 0;   //  0 <= i - j <= m
    for (int i = 1; i <= n; i ++ )
    {
        if (hh <= tt && i - que[hh] > m) hh ++ ;
        f[i] = max(f[i-1],s[i] + g(que[hh]));       //正数的话不用max
        while (hh <= tt && g(i) >= g(que[tt])) tt -- ;
        que[ ++ tt] = i;  // i - j >= 0 故先入队

    }
    printf("%lld\n", f[n]);
    return 0;
}

```

#### 例8.hdu3401 :（二维dp）待补

[trade]:http://acm.hdu.edu.cn/showproblem.php?pid=3401



##### 题意：

股票在t天内每天买或卖或不作为，知道每一天每一支股票的买卖价格api,bpi和限购或卖的量asi,bsi，以及每天最多持有的股票数maxp，还有每次交易必须隔至少w天的限制，求最大的收益。

[题解1]:https://blog.csdn.net/qq_45621109/article/details/107970989
[题解2]:https://blog.csdn.net/qq_45621109/article/details/107970989



